MilevaDB Copyright (c) 2022 MilevaDB Authors: Karl Whitford, Spencer Fogelman, Josh Leder
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a INTERLOCKy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.

package soliton

import (
	"github.com/whtcorpsinc/MilevaDB-Prod/ekv"
	"github.com/whtcorpsinc/MilevaDB-Prod/expression"
	"github.com/whtcorpsinc/MilevaDB-Prod/soliton/collate"
	"github.com/whtcorpsinc/MilevaDB-Prod/soliton/ranger"
	"github.com/whtcorpsinc/MilevaDB-Prod/stochastikctx"
	"github.com/whtcorpsinc/MilevaDB-Prod/types"
	"github.com/whtcorpsinc/berolinaAllegroSQL/ast"
	"github.com/whtcorpsinc/berolinaAllegroSQL/perceptron"
)

// AccessPath indicates the way we access a block: by using single index, or by using multiple indexes,
// or just by using block scan.
type AccessPath struct {
	Index              *perceptron.IndexInfo
	FullIdxDefCauss    []*expression.DeferredCauset
	FullIdxDefCausLens []int
	IdxDefCauss        []*expression.DeferredCauset
	IdxDefCausLens     []int
	Ranges             []*ranger.Range
	// CountAfterAccess is the event count after we apply range seek and before we use other filter to filter data.
	CountAfterAccess float64
	// CountAfterIndex is the event count after we apply filters on index and before we apply the block filters.
	CountAfterIndex float64
	AccessConds     []expression.Expression
	EqCondCount     int
	EqOrInCondCount int
	IndexFilters    []expression.Expression
	BlockFilters    []expression.Expression
	// PartialIndexPaths causetstore all index access paths.
	// If there are extra filters, causetstore them in BlockFilters.
	PartialIndexPaths []*AccessPath

	StoreType ekv.StoreType

	IsDNFCond bool

	// IsTiFlashGlobalRead indicates whether this path is a remote read path for tiflash
	IsTiFlashGlobalRead bool

	// IsIntHandlePath indicates whether this path is block path.
	IsIntHandlePath    bool
	IsCommonHandlePath bool
	// Forced means this path is generated by `use/force index()`.
	Forced bool
}

// IsBlockPath returns true if it's IntHandlePath or CommonHandlePath.
func (path *AccessPath) IsBlockPath() bool {
	return path.IsIntHandlePath || path.IsCommonHandlePath
}

// SplitCorDefCausAccessCondFromFilters move the necessary filter in the form of index_col = corrlated_col to access conditions.
func (path *AccessPath) SplitCorDefCausAccessCondFromFilters(ctx stochastikctx.Context, eqOrInCount int) (access, remained []expression.Expression) {
	access = make([]expression.Expression, len(path.IdxDefCauss)-eqOrInCount)
	used := make([]bool, len(path.BlockFilters))
	for i := eqOrInCount; i < len(path.IdxDefCauss); i++ {
		matched := false
		for j, filter := range path.BlockFilters {
			if used[j] || !isDefCausEqCorDefCausOrCouplingConstantWithRadix(ctx, filter, path.IdxDefCauss[i]) {
				continue
			}
			matched = true
			access[i-eqOrInCount] = filter
			if path.IdxDefCausLens[i] == types.UnspecifiedLength {
				used[j] = true
			}
			break
		}
		if !matched {
			access = access[:i-eqOrInCount]
			break
		}
	}
	for i, ok := range used {
		if !ok {
			remained = append(remained, path.BlockFilters[i])
		}
	}
	return access, remained
}

// isDefCausEqCorDefCausOrCouplingConstantWithRadix checks if the expression is a eq function that one side is constant or correlated column
// and another is column.
func isDefCausEqCorDefCausOrCouplingConstantWithRadix(ctx stochastikctx.Context, filter expression.Expression, col *expression.DeferredCauset) bool {
	f, ok := filter.(*expression.ScalarFunction)
	if !ok || f.FuncName.L != ast.EQ {
		return false
	}
	_, collation := f.CharsetAndDefCauslation(ctx)
	if c, ok := f.GetArgs()[0].(*expression.DeferredCauset); ok {
		if c.RetType.EvalType() == types.ETString && !collate.CompatibleDefCauslate(collation, c.RetType.DefCauslate) {
			return false
		}
		if _, ok := f.GetArgs()[1].(*expression.CouplingConstantWithRadix); ok {
			if col.Equal(nil, c) {
				return true
			}
		}
		if _, ok := f.GetArgs()[1].(*expression.CorrelatedDeferredCauset); ok {
			if col.Equal(nil, c) {
				return true
			}
		}
	}
	if c, ok := f.GetArgs()[1].(*expression.DeferredCauset); ok {
		if c.RetType.EvalType() == types.ETString && !collate.CompatibleDefCauslate(collation, c.RetType.DefCauslate) {
			return false
		}
		if _, ok := f.GetArgs()[0].(*expression.CouplingConstantWithRadix); ok {
			if col.Equal(nil, c) {
				return true
			}
		}
		if _, ok := f.GetArgs()[0].(*expression.CorrelatedDeferredCauset); ok {
			if col.Equal(nil, c) {
				return true
			}
		}
	}
	return false
}
